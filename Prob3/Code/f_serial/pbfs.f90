program main
	implicit none

	!  A graph in compressed-adjacency-list (CSR) form
    type graph
        integer :: nv ! number of vertices
        integer*8 :: ne ! number of edges
        integer, allocatable :: nbr(:) ! array of neighbors of all vertices
        integer, allocatable :: firstnbr(:) ! index in nbr() of first neighbor of each vtx
    end type graph
    type (graph) total_graph

	integer :: i, j, k
	character(len=32) :: filename=''
	character(len=32) :: arg
	integer, parameter :: BLOCK=16777216
	integer :: startvtx ! starting vertex
	integer :: nlevelsp
	integer, allocatable :: levelsize(:)
	integer :: reached 
	real :: start_time, end_time, elapsed_time, gteps
	character*80 tmp1,tmp2,tmp3

	do i = 1, command_argument_count()
		call get_command_argument(i, arg)
		if (i.eq.1) filename = trim(arg) 
	enddo

	if (filename.eq.'') then
		write(*,*), 'usage: bfs <filename>'
		call exit(1)
	endif

	! read the graph from file which is generated by the C program using fwrite 
	call get_time(start_time)
	open(unit=3, file=filename, FORM='UNFORMATTED', access='stream')
	read(3) startvtx, total_graph%ne, total_graph%nv
	allocate(total_graph%nbr(0:total_graph%ne-1))
	allocate(total_graph%firstnbr(0:total_graph%nv))
	if (total_graph%ne.lt.BLOCK) then
		read(3) total_graph%nbr(0:total_graph%ne-1)
	else
		j = (total_graph%ne-1)/BLOCK
		k = mod((total_graph%ne-1), BLOCK)
		do i=0, j-1
			read(3) total_graph%nbr((i*BLOCK):(i+1)*BLOCK-1)
		enddo
		if (k.ne.0) read(3) total_graph%nbr(j*BLOCK:(j*BLOCK)+k)
	endif
	read(3) total_graph%firstnbr(0:total_graph%nv)
	close(3)
	call get_time(end_time)
	elapsed_time = end_time-start_time
	write(unit=tmp1, fmt="(F10.6)")elapsed_time
	write (*, "(a)"), "Elapsed Time to read and construct graph: "//trim(adjustl(tmp1))//NEW_LINE('A')

	! print graph
	call print_CSR_graph( total_graph%nv, total_graph%ne, total_graph%nbr, total_graph%firstnbr )

	write(unit=tmp1, fmt=*)startvtx
	write(*,"(a)"), NEW_LINE('A')//"Starting vertex for BFS is " // trim(adjustl(tmp1)) // NEW_LINE('A')

	call get_time(start_time)
	allocate(levelsize(0:total_graph%nv-1))
	! traverse graph
	call bfs( startvtx, total_graph%nv, total_graph%ne, total_graph%nbr, total_graph%firstnbr, nlevelsp, levelsize )
	call get_time(end_time)

	reached = 0
	do i=0, nlevelsp-1
		reached = reached + levelsize(i)
	end do	
	write(unit=tmp1, fmt=*)startvtx
	write(unit=tmp2, fmt=*)nlevelsp
	write(unit=tmp3, fmt=*)reached
	write(*,"(a)"), "Breadth-first search from vertex "//trim(adjustl(tmp1))// " reached " // &
		trim(adjustl(tmp2)) // " levels and " // trim(adjustl(tmp3)) // " vertices."
	do i=0, nlevelsp-1
	    write(unit=tmp1, fmt=*)i
	    write(unit=tmp2, fmt=*)levelsize(i)
		write (*,"(a)"), "level "//trim(adjustl(tmp1))//" vertices: "//trim(adjustl(tmp2))
	end do

	elapsed_time = end_time-start_time
	if (elapsed_time.eq.0) then
		gteps = 0
	else
		gteps = (reached/elapsed_time)/1000000
	endif
	write(unit=tmp1, fmt="(F10.6)")gteps
	write (*, "(a)"), NEW_LINE('A')//"GTEPs: "//trim(adjustl(tmp1))
	write(unit=tmp1, fmt="(F10.6)")elapsed_time
	write (*, "(a)"), "Elapsed time: "//trim(adjustl(tmp1))

	deallocate(levelsize)
	deallocate(total_graph%nbr)
	deallocate(total_graph%firstnbr)
end program main

!c======================================================================
subroutine bfs( s, nv, ne, nbr, firstnbr, nlevelsp, levelsize )
	integer, intent(in) :: s, nv
	integer*8, intent(in) :: ne
	integer, intent(in) :: nbr(0:ne-1), firstnbr(0:nv)
	integer, intent(out) :: nlevelsp
	integer, intent(out) :: levelsize(0:nv-1)

	integer :: thislevel, v, w, e
	integer :: back, front
	integer, allocatable :: level(:), queue(:)

	allocate(level(0:nv-1), queue(0:nv-1))
	! initially, queue is empty, all levels are -1
	back = 0 ! position next element will be added to queue
	front = 0 ! position next element will be removed from queue
	do v=0,nv-1
		level(v) = -1
	enddo

	! assign the starting vertex level 0 and put it on the queue to explore
	thislevel = 0
	level(s) = 0
	levelsize(0) = 1
	queue(back) = s
	back = back + 1

	! loop over levels, then over vertices at this level, then over neighbors
	do while(levelsize(thislevel) > 0) 
		levelsize(thislevel+1) = 0
		do i=0, levelsize(thislevel)-1 
			v = queue(front) ! v is the current vertex to explore from
			front = front + 1
			do e = firstnbr(v), firstnbr(v+1)-1
				w = nbr(e) ! w is the current neighbor of v
				if (level(w).eq.-1) then ! w has not already been reached
					level(w) = thislevel + 1
					levelsize(thislevel+1) = levelsize(thislevel+1)+1
					queue(back) = w ! put w on queue to explore
					back = back +1
				end if
			end do
		end do
		thislevel = thislevel + 1
	end do

	deallocate(level)
	deallocate(queue)
	nlevelsp = thislevel
end subroutine bfs

!c======================================================================
subroutine print_CSR_graph( nv, ne, nbr, firstnbr )
	implicit none
	integer :: nv, i
	integer*8 :: ne
	integer :: nbr(0:ne-1), firstnbr(0:nv)
	integer :: vlimit = 20
	integer :: elimit = 50
	character*80 tmp1,tmp2

	write(unit=tmp1, fmt=*)nv
	write(unit=tmp2, fmt=*)ne
	write(*,"(A)"), 'Graph has '//trim(adjustl(tmp1))//' vertices and '//trim(adjustl(tmp2))//' edges.'
	write(*,"(A)",advance="no"), 'fristnbr = '
	if (nv+1 < vlimit) vlimit = nv+1
	do i=0, vlimit-1
		write(unit=tmp1, fmt=*)firstnbr(i)
		write(*,'(A,A)',advance="no"), trim(adjustl(tmp1)), ' '
	enddo
	if (nv+1 > vlimit) write(*,'(A)',advance="no"), ' ...'
	write(*,*), ''
	if (ne < elimit) elimit = ne
	write(*,"(A)",advance="no"), 'nbr = '
	do i=0, elimit-1
		write(unit=tmp1, fmt=*)nbr(i)
		write(*,'(A,A)',advance="no"), trim(adjustl(tmp1)), ' '
	enddo
	if (ne > elimit) write(*,'(A)',advance="no"), ' ...'
	write(*,*), ''
end subroutine print_CSR_graph

!c======================================================================
subroutine get_time( time0 )
	implicit none	
	integer :: time_array_0(8)
	real :: time0

	call date_and_time(values=time_array_0)
    time0 = time_array_0 (5) * 3600 + time_array_0 (6) * 60 &
		+ time_array_0 (7) + 0.001 * time_array_0 (8)
	
end subroutine get_time
